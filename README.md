# Алгоритм Viewstamped Replication Revisited

## 3 Обзор
Граф состояний репликаций требует, чтобы репликации запускались в одинаковом начальном состоянии, и чтобы операции были детерминированы. С этими допущениями, легко увидеть, что реплики в конечном итоге будут в одинаковом состоянии, если они выполнили одинаковую последовательность операций. Проблема для протокола репликаций в гарантии того, что операции выполняются в одинаковом порядке на всех репликах несмотря на одновременный запросы от клиентов и несмотря на отказы в работе.

VR использует первичную реплику (лидера) для упорядочения запросов от клиентов; другие реплики - это **резервные копии** (англ. *backups*), которые просто принимают порядок, выбранный лидером. Использование лидера предоставляет простое решение для требования порядка запросов, но это добавляет проблему: что случится, если лидер откажет? VR имеет решает эту проблему, разрешая различным репликам брать на себя роль лидера с течением времени. Система проходит через последовательность представлений (англ. view). В каждой картине одна из реплик выбрана в качестве лидера. Резервные копии проверяют лидера, и если он, по-видимому, неисправен, они выполняют протокол **смены представления** (англ. *view change*) для выбора нового лидера.

Для корректной работы по изменению вида в течение смены представления состояние системы в следующем представлении должно отражать все клиентские операции, которые были выполнены в предыдущих представлениях в предыдущем выбранном порядке. Мы поддерживаем это требование, имея ожидание лидера до тех пор, пока по крайней мере f + 1 реплика (включая самого лидера) не будут знать о запросе клиента до его выполнения, и инициализируя состояние нового представления через опрашивание f + 1 реплики. Таким образом, каждый запрос, известен как, кворум (англ. quorum), и новое представление начинается с кворума.

VR также предоставляет путь для узлов, которые не удалось восстановить, а затем продолжить обработку. Это важно, поскольку в противном случае количество отказов узлов могло бы в конечном счете превысить порог. Корректное восстановление требует, чтобы восстанавливаемая реплика присоединялась к протоколу только после того, как он знает состояние по крайней мере не старее того, когда реплика отказала. Тогда он может правильно реагировать, если это необходимо для кворума.
Очевидно, это требование могло бы быть удовлетворено, если у нас каждая реплика записывала, что она знает на диск перед каждым сообщением. Но мы не требуем использование диск для этой цели.

Итак, VR использует 3 суб-протокола, которые работает вместе и гарантируют корректность:
* **Обычный случай**, обрабатывающий пользовательские сообщения.
* **Изменение представлений** для выбора нового лидера.
* **Восстановление отказавшей реплики**, чтобы она могла заново присоединиться к группе.

Эти суб-протоколы детально описаны в следующем разделе.

## 4 VR протокол
Этот раздел описывает как VR работает при допущении, что группа из реплик фиксирована. Мы опишем несколько путей для улучшения производительности протоколов в разделе 5 и оптимизаций в разделе 6. Реконфигурации протокола, который позволяет группе реплик изменяться описана в разделе 7.

Фигура 2 показывает состояние VR слоя реплики. Подлинность лидера не записана в состоянии, но скорее вычисляется из **номера представления** (англ. *view-number*) и конфигурации (англ. configuration). Реплики нумеруются на основе их IP-адресов: реплика с наименьшим IP-адресом - реплика под номером 1. Лидер выбирается циклически, начиная с реплики 1, когда система переходит в новые представления. Статус (англ. status) показывает каком суб-протоколом занимается реплика.

Клиентская сторона также имеет состояние. Оно записывает конфигурацию и текущий номер представления, по его мнению, что позволяет знать какая реплика является в данный момент первичной. Каждое сообщение, посланное клиенту, сообщение ему о текущей номере представления, это позволяет клиенту следить за лидером.

Кроме того клиент записывает собственный номер (англ. client-id) и текущий номер запроса (англ. request-number). Клиенту позволено иметь только один outstanding запрос за раз. Каждому запросу дан номер клиентом и последующие запросы должны иметь больший номер, чем предыдущие; мы опишем как клиенты гарантируют это, если они отказывают и восстанавливаются в разделе 4.5. Номер запроса используется репликами для избежания выполнения запроса больше 1 раза; он также используется клиентом для отбрасывания дублирующихся ответов на его запросы. 

### 4.1 Обычная операция
Этот раздел описывает, как VR работает, когда лидер не отказал. Реплики принимают участие в обработке клиентский запросов только когда их статус *нормальный*. Это ограничение критично для корректности, описанной в разделе 8.

Описание протокола допускает, что все участвующие реплики имеют одинаковое представление. Каждое сообщение, посланное от одной реплики до другой, содержит текущий номер представления отправителя. Реплики обрабатывают только сообщение нормального протокола, содержащие номер представления, который совпадает с номером представления, который они знают. Если отправитель впереди, то реплика выполняет **перенос состояние** (англ. *state transfer*): она запрашивает информацию, которой ей не хватает из других реплик и использует эту информацию для приведения себя до актуального состояния перед обработкой сообщения. Перенос состояния описана дальше в разделе 5.2.

Протокол обработки запросов работает следующим образом. Описание игнорирует ряд мелких деталей таких, как переотправка сообщений протокола, которые не получили ответов.

Фигура 2: VR состояние реплики
* *Конфигурация*. Это сортированный массив, содержащий IP-адреса каждой из 2f + 1 реплики.
* *Номер реплики*. Это индекс в конфигурации, где хранится IP-адрес текущей реплики.
* Текущий *номер представления*. Изначально, 0.
* Текущий *статус*. Либо *нормальный*, либо *изменение представления*, либо *восстановление*.
* *Номер операции* назначенный самому недавнему полученному запросу. Изначально, 0.
* *Лог*. Это массив, содержащий записи номеров операций. Записи содержат запросы, которые были получены до сих пор в их указанном порядке.
* *Номер коммита*. Это номер последней совершенной операции.
* *Таблица клиентов*. Сюда записывается для каждого клиента ряд самых недавних запросов, а также если запрос был выполнен, результат, отправленный в ответ на запрос.

1. Клиент посылает сообщение <REQUEST op, c, s> лидеру, где op - операция (с аргументами), которую нужно выполнить, с - номер клиента, s - номер запроса привязанного к запросу.
2. Когда лидер получает запрос, он сравнивает его номер с информацией в таблице клиентов. Если номер s не больше, чем информация в таблице, он сбрасывает запрос. Но перешлет его, если запрос последний от клиента и уже был выполнен.




 

### 4.2 View Changes
### 4.3 Recovery
### 4.4 Non-deterministic Operations
### 4.5 Client Recovery

## 5 Pragmatics
Описание протоколов, представленное в предыдущем разделе игнорировал ряд важных вопросов, которые должны быть решены на практике. В этом разделе мы опишем как обеспечить хорошую производительность при восстановлении узла, переноса состояния и изменения представления. Во всех этих случаях ключом для решения проблемы является эффективное управление журналом логирования.

### 5.1 Efficient Recovery
### 5.2 State Transfer
### 5.3 View Changes
